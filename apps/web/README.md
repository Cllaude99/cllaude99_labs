## 목차

1. [Traders](#Traders)
2. [Sketch](#Sketch)

---

# Traders

## 프로젝트 소개

**"과거로 돌아가 주식 투자를 다시 해볼 수 있다면?"**

2010년부터 2024년까지의 실제 한국 주식 데이터를 기반으로, 과거 시점으로 돌아가 투자 결정을 내리고 결과를 확인하는 실시간 주식 시뮬레이션 게임입니다. 주식 종목명은 비공개로 진행되며, 각 연도의 경제 뉴스와 힌트를 활용해 15년간의 투자 여정을 완주하는 것이 목표입니다.

게임은 2010년 1월부터 시작하여 매년 1월에 퀴즈를 풀거나 광고를 시청하여 힌트를 획득하고, 2월부터 11월까지 실시간으로 변동하는 주가를 보며 매수/매도 결정을 내립니다. 12월 31일에는 자동으로 결산이 이루어지며, 최종 자산이 다음 연도의 시드머니가 됩니다. 2년마다 특별 이벤트로 블러 차트를 획득하여 해당 연도의 전체적인 추세를 미리 확인할 수 있으며, 2024년 12월 31일에 게임이 종료되면 그동안 익명이었던 종목명이 공개되고 전체 유저 랭킹을 확인할 수 있습니다.

---

## 사용한 모듈 및 도구 또는 기술

### Frontend

**프레임워크 및 라이브러리**

- React 18.2, TypeScript 5.0, Vite 4.0

**상태 관리**

- Zustand 4.4 - 게임 상태, 포트폴리오 관리
- TanStack Query 5.0 - 서버 데이터 캐싱

**차트 및 실시간 통신**

- Lightweight Charts 4.0 - TradingView 공식 차트 라이브러리
- Supabase Realtime - WebSocket 기반 실시간 주가 스트리밍

**스타일링 및 애니메이션**

- Emotion 11.11 - CSS-in-JS
- Framer Motion 10.0 - 애니메이션

**라우팅**

- React Router DOM 6.20

### Backend (BaaS)

**Supabase**

- Database - PostgreSQL 15
- Realtime - WebSocket 주가 스트리밍
- Auth - 소셜 로그인 (Google, Kakao)
- Storage - 뉴스 이미지, 차트 캐시
- Edge Functions - Deno 기반 API

### 데이터 소스

**한국 주식 데이터**

- KRX (한국거래소) 공개 API
- FinanceDataReader - Python 라이브러리로 데이터 수집
- 2010-2024년 일별 OHLCV 데이터

### DevOps

- Vercel - 자동 배포
- Sentry - 에러 추적
- Playwright - E2E 테스트
- Jest - 단위 테스트

---

## 기능

### 게임 플레이 구조

게임은 2010년 1월 1일에 초기 시드머니 1000만원과 함께 시작됩니다. 10개의 익명화된 한국 주식 종목이 제공되며, 각 종목은 알파벳 코드(A, B, C 등)로만 표시됩니다. 실제 기업명은 게임 종료 시까지 비공개됩니다.

매년 1월 1일에는 정보 획득 단계가 시작됩니다. 플레이어는 경제 관련 퀴즈 3문제를 풀어 정답 개수에 따라 차등 보상을 받거나, 30초 광고를 시청하여 레벨 1 힌트를 무조건 획득할 수 있습니다. 퀴즈에서 3문제를 맞추면 레벨 2 힌트(구체적인 경제 정보)를, 2문제를 맞추면 레벨 1 힌트(일반적인 사회 이슈)를 받습니다. 레벨 1 힌트는 "이 해에는 스마트폰 보급이 확대되었습니다"와 같은 일반 정보를, 레벨 2 힌트는 "삼성전자가 갤럭시S 시리즈를 출시하며 IT 업종이 급성장했습니다"와 같은 구체적 정보를 제공합니다.

2월부터 11월까지는 실시간 차트로 주가 변동을 확인하며 투자를 진행합니다. 1개월이 30초에서 1분으로 압축 재생되며, 언제든지 매수/매도가 가능하고 포트폴리오의 실시간 수익률을 확인할 수 있습니다. 재생 속도는 1배속, 2배속, 5배속으로 조절 가능합니다.

12월 31일 23시 59분까지 모든 투자 결정을 완료해야 하며, 보유 중인 주식은 자동으로 12월 31일 종가에 매도됩니다. 최종 자산은 현금과 주식 평가액을 합산하여 계산되고, 수익률이 계산되어 전체 유저 랭킹이 업데이트됩니다. 전년도 최종 자산이 새로운 시드머니가 되어 다음 연도가 시작됩니다.

2년마다(2012년, 2014년, 2016년, 2018년, 2020년, 2022년, 2024년) 특별 이벤트가 발생합니다. 퀴즈를 맞추거나 광고를 시청하면 "블러 차트"를 획득할 수 있습니다. 블러 차트는 해당 연도 1월부터 12월까지의 주가 흐름 중 3개월 기간의 흐름을 보여줍니다. 기본적으로 차트가 블러 처리되어 있지만, 블러 차트 아이템을 사용하면 3개월 동안의 흐름을 볼 수 있어 전체적인 상승/하락 추세를 파악하여 장기 투자 전략을 수립하는 데 유용합니다.

2024년 12월 31일에 게임이 종료되면 15년간의 투자 여정이 완료됩니다. 최종 수익률이 계산되고 전체 랭킹을 확인할 수 있으며, 이제서야 A, B, C가 어떤 기업이었는지 종목명이 공개됩니다. 연도별 투자 히스토리를 리플레이할 수도 있습니다.

### 익명 종목 시스템

10개의 한국 주식 종목이 제공되며, 각 종목은 카테고리(엔터, IT, 바이오, 식품, 뷰티, 화학, 조선 등)와 알파벳 코드로만 표시됩니다. 종목 리스트는 A 엔터, B 엔터, C IT, D IT 형태로 표시되고 현재가만 보이며, 기업명은 물음표로 표시됩니다. 게임 종료 후에만 A 엔터(삼성전자)처럼 실명이 공개됩니다.

### 힌트 시스템

매년 1월 1일에 퀴즈를 풀거나 광고를 보는 방식으로 힌트를 획득합니다. 퀴즈는 3문제가 제시되며, 정답 개수에 따라 레벨 1 또는 레벨 2 힌트를 받습니다. 광고 시청 시에는 30초 광고를 보면 무조건 레벨 1 힌트를 획득합니다.

### 실시간 차트 시스템

Lightweight Charts 라이브러리를 사용하여 1년치 주가 데이터를 라인 차트로 표시합니다. 현재가와 등락률이 실시간으로 업데이트되며, WebSocket으로 1일치 데이터를 0.1초마다 전송합니다. 1개월(30일)이 30초에 재생되어 1일이 1초로 압축됩니다. 재생 속도는 1배속, 2배속, 5배속으로 조절 가능합니다.

### 블러 차트 미리보기

2년마다 발생하는 특별 이벤트로 블러 차트를 획득하면, 해당 연도의 1년치 추세를 블러 처리된 형태로 미리 볼 수 있습니다. Canvas 블러 효과를 적용하여 전반적인 상승 또는 하락 추세는 파악할 수 있지만 세부 데이터는 숨겨져 있어, 장기 투자 전략 수립에 도움이 됩니다.

### 포트폴리오 및 거래 시스템

포트폴리오 대시보드에서 현금, 주식 평가액, 총자산을 실시간으로 확인할 수 있습니다. 보유 종목별로 수량, 수익률, 평가액이 표시됩니다. 매수 시에는 현재가와 매수 가능 수량을 확인하고 원하는 수량을 입력하여 거래를 체결할 수 있습니다. 잔액이 부족한 경우 거래가 제한되며, 모든 거래는 Supabase Realtime을 통해 즉시 동기화됩니다.

### 랭킹 시스템

전체 유저의 최종 자산과 수익률을 기준으로 랭킹이 표시됩니다. 순위, 닉네임, 최종자산, 수익률이 실시간으로 업데이트되며, 연도별 랭킹과 수익률 분석 기능도 제공됩니다.

### 게임 튜토리얼

게임을 처음 시작하는 플레이어를 위한 온보딩 플로우가 제공됩니다. 게임 소개, 종목 설명, 힌트 시스템, 투자 방법, 블러 차트, 연말 결산 등 게임의 핵심 요소를 단계별로 안내합니다.

---

## 구현하면서 고민한점

(비워두기)

---

## 스프린트별 진행할 작업

### Sprint 1 - 데이터 수집 및 차트 엔진 (1주)

한국 주식 10개 종목의 2010-2024 데이터를 수집하고 실시간 차트 렌더링 구현

**Frontend 작업**

- Vite + React + TypeScript 프로젝트 셋업
- Lightweight Charts 통합
- 목업 데이터로 1개 종목 차트 렌더링
- 시간 흐름 제어 UI (재생/일시정지/1x/2x/5x)
- Zustand 스토어 설계 (게임 상태, 포트폴리오)

**Backend 작업**

- Supabase 프로젝트 생성
- DB 스키마 설계 (stocks, stock_prices, users, game_progress, portfolios, transactions 테이블)
- 한국 주식 10개 종목 데이터 수집 (KRX API 또는 FinanceDataReader 활용)
- Supabase Auth 설정

**산출물**

- DB ERD 문서
- 10개 종목 데이터 적재 완료
- 1개 종목 실시간 차트 동작

---

### Sprint 2 - 매매 시스템 및 연도 사이클 (1.5주)

매수/매도 기능 및 연도별 자동 이월 시스템 구현

**Frontend 작업**

- 매수/매도 모달 UI
- 포트폴리오 대시보드
- 실시간 수익률 계산
- 12월 31일 자동 결산 로직 (모든 보유 주식 강제 매도, 최종 자산 계산, 다음 해로 이월)

**Backend 작업**

- 거래 API (Edge Functions) - 잔액 확인, 거래 체결, 현금 차감, 거래 내역 저장
- 실시간 주가 스트리밍 Edge Function - 1일치 데이터를 1초에 하나씩 전송, 속도 조절

**산출물**

- 매매 기능 완성
- 연도 자동 이월 시스템

---

### Sprint 3 - 힌트 시스템 (1주)

1월 퀴즈 및 힌트 획득 시스템 구현

**Frontend 작업**

- 1월 진입 시 퀴즈 모달 표시
- 광고 시청 버튼 (또는 타이머)
- 힌트 표시 UI (레벨별)

**Backend 작업**

- 퀴즈 DB 구축 (yearly_quizzes 테이블 - year, questions, level1_hint, level2_hint)
- 2010-2024년 각 연도별 퀴즈 3문제 및 힌트 데이터 작성

**산출물**

- 퀴즈 시스템 완성
- 레벨별 힌트 표시

---

### Sprint 4 - 멀티 종목 및 블러 차트 (1.5주)

10개 종목 차트 및 블러 미리보기 구현

**Frontend 작업**

- 종목 탭 전환 UI
- 종목 비교 기능 (최대 3개)
- 블러 차트 구현 (Canvas 블러 효과 적용)

**Backend 작업**

- 블러 차트 이벤트 데이터 (blur_events 테이블 - year, description)
- 2012, 2014, 2016, 2018, 2020, 2022, 2024년 블러 이벤트 데이터 작성

**산출물**

- 10개 종목 완전 구현
- 블러 차트 기능

---

### Sprint 5 - 랭킹 및 게임 종료 (1주)

랭킹 시스템 및 종목명 공개 구현

**Frontend 작업**

- 랭킹 페이지
- 게임 종료 화면 (최종 자산, 종목명 공개)
- 투자 히스토리 리플레이 (연도별 거래 내역 및 수익률)

**Backend 작업**

- 랭킹 API (최종 자산 기준 정렬, 상위 100명)
- 종목명 복호화 로직 (게임 완료 확인 후 종목명 공개)

**산출물**

- 랭킹 시스템
- 게임 종료 화면
- 종목명 공개
- 완성된 게임 (Vercel 배포)

# Sketch

## 프로젝트 소개

여러 사용자가 동시에 같은 캔버스에 접속하여 도형을 그리고 텍스트를 입력하며, 실시간으로 아이디어를 시각화할 수 있는 실시간 협업 화이트보드 서비스입니다.

해당 서비스는 Excalidraw, FigJam과 같은 협업 도구에서 영감을 받았습니다.
사용자는 캔버스에서 자유롭게 사각형, 원, 화살표, 자유 곡선을 그릴 수 있으며, Apple Pencil과 같은 펜 입력 장치의 필압을 지원하여 자연스러운 손글씨를 구현합니다. 여러 사용자가 동일한 룸에 접속하면 각 사용자의 커서 위치가 실시간으로 표시되고, 도형을 추가하거나 수정할 때 즉시 다른 사용자의 화면에 반영됩니다. 오프라인 상태에서도 작업이 가능하며, 다시 연결되면 자동으로 변경사항이 동기화됩니다.

프로젝트의 목표는 Canvas API를 활용한 고성능 렌더링 최적화와 Supabase Realtime을 통한 실시간 협업 구현입니다. 10,000개 이상의 도형이 있어도 60fps를 유지하기 위해 Viewport Culling과 Layer 분리 기법을 적용하고, 네트워크 지연 환경에서도 부드러운 사용자 경험을 제공하기 위해 Optimistic Update 패턴과 Throttle 기법을 사용합니다.

---

## 사용한 모듈 및 도구 또는 기술

### Frontend

**프레임워크 및 라이브러리**

- React 18, TypeScript, Vite

**Canvas 렌더링**

- React-Konva 18.2 - React로 Canvas 제어
- Konva.js - Canvas API 추상화 레이어

**실시간 협업**

- Supabase Realtime - WebSocket 기반 실시간 데이터 동기화
- Supabase Database - PostgreSQL 데이터 저장소

**손그림 스타일**

- rough.js 4.6 - 손으로 그린 듯한 스타일 렌더링

**펜 입력 및 필압**

- perfect-freehand 1.2 - 필압 기반 자연스러운 곡선 생성
- Pointer Events API - 펜 입력 감지 (pressure, tilt)

**상태 관리**

- Zustand 4.4 - 로컬 UI 상태 관리
- TanStack Query 5.0 - 서버 상태 캐싱

**스타일링 및 애니메이션**

- Emotion 11.11 - CSS-in-JS
- Motion (Framer Motion) 10.0 - 애니메이션

**성능 최적화**

- lodash-es - Throttle, Debounce

**라우팅**

- React Router DOM 7

### Backend (BaaS)

**Supabase**

- Database - PostgreSQL (도형, 사용자, 룸 데이터 저장)
- Realtime - WebSocket 기반 실시간 동기화
  - Broadcast - 룸 내 모든 사용자에게 메시지 전송
  - Presence - 온라인 사용자 및 커서 위치 추적
- Auth - 소셜 로그인 (Google, GitHub)
- Storage - 이미지 업로드, PNG 내보내기

### DevOps

- Vercel - 프론트엔드 배포
- Supabase Cloud - 백엔드 호스팅
- Sentry - 에러 추적
- Playwright - E2E 테스트
- Jest - 단위 테스트

---

## 기능

### 무한 캔버스 시스템

무한 캔버스는 사용자가 제한 없이 자유롭게 작업할 수 있는 공간을 제공합니다. Viewport 좌표계를 통해 x, y, zoom 값을 관리하며, Screen 좌표와 Canvas 좌표 간 변환 로직을 구현합니다. Space 키를 누른 채로 드래그하면 캔버스를 이동할 수 있고, 마우스 휠을 사용하여 0.1배에서 5.0배까지 줌 인/아웃이 가능합니다. 줌 중심점은 마우스 커서 위치를 기준으로 유지되어 자연스러운 확대/축소 경험을 제공합니다.

### 도형 그리기 도구

사용자는 사각형, 원, 선, 화살표를 그릴 수 있습니다. 도구를 선택한 후 마우스로 드래그하면 실시간으로 도형이 그려지며, 마우스를 떼는 순간 도형이 확정됩니다. 모든 도형은 rough.js 라이브러리를 사용하여 손으로 그린 듯한 자연스러운 스타일로 렌더링됩니다. roughness와 bowing 파라미터를 조정하여 선의 흔들림 정도와 곡선의 굴곡을 세밀하게 제어할 수 있습니다.

### 실시간 협업 엔진

여러 사용자가 동시에 같은 캔버스에서 작업할 수 있습니다. Supabase Realtime의 Broadcast 기능을 사용하여 도형의 추가, 수정, 삭제 이벤트를 실시간으로 전송합니다. 사용자가 도형을 추가하면 해당 이벤트가 룸의 모든 참여자에게 브로드캐스트되고, 각 클라이언트는 받은 데이터를 기반으로 자신의 캔버스를 업데이트합니다.

동시성 제어는 Last-Write-Wins 전략을 사용합니다. 각 도형 변경사항에 타임스탬프를 포함하여 전송하고, 충돌이 발생하면 더 최근의 변경사항을 우선합니다. 네트워크 지연을 최소화하기 위해 Optimistic Update 패턴을 적용하여 로컬에서 먼저 UI를 업데이트한 후 서버 응답을 기다립니다.

### 커서 공유 및 온라인 사용자 표시

Supabase Realtime의 Presence 기능을 사용하여 각 사용자의 커서 위치와 온라인 상태를 실시간으로 공유합니다. 사용자가 룸에 입장하면 자동으로 고유한 색상이 할당되고, 커서를 움직이면 다른 사용자의 화면에도 해당 위치에 커서가 표시됩니다. 커서 이동 이벤트는 16ms마다 전송되도록 Throttle을 적용하여 네트워크 대역폭을 90% 절감합니다. 우측 상단에는 현재 온라인 상태인 사용자 목록이 아바타 형태로 표시됩니다.

### 선택 및 변형 도구

사각형 영역을 드래그하여 여러 도형을 한 번에 선택할 수 있습니다. 선택된 도형 주변에는 Transformer가 나타나며, 핸들을 드래그하여 크기를 조절하거나 회전시킬 수 있습니다. React-Konva의 Transformer 컴포넌트를 사용하여 크기 조절 핸들, 회전 핸들이 자동으로 제공됩니다. Delete 키를 누르면 선택된 도형이 삭제되고, Ctrl+D로 복제할 수 있습니다.

### 텍스트 도구

캔버스의 원하는 위치를 더블클릭하면 텍스트 편집 모드가 시작됩니다. HTML의 contentEditable div를 Canvas 위에 오버레이하여 텍스트 입력을 처리하고, 입력이 완료되면 Canvas Text 객체로 렌더링합니다. 폰트 크기, 색상, 굵기를 조정할 수 있으며, 한글 IME 입력도 정상적으로 처리됩니다.

### 자유 곡선 및 필압 지원

Pen 도구를 선택하면 자유롭게 곡선을 그릴 수 있습니다. Pointer Events API를 사용하여 펜 입력 장치의 필압(pressure), 기울기(tilt) 정보를 감지하고, perfect-freehand 라이브러리로 부드럽고 자연스러운 선을 생성합니다. Apple Pencil, Surface Pen, Wacom 펜과 같은 디지털 펜에서 필압이 강할수록 선이 두껍게 그려지고, 약할수록 얇게 그려집니다. pointerType을 확인하여 터치 입력은 무시하고 펜 입력만 처리하는 Palm Rejection 기능을 구현합니다.

### 화살표 및 그룹화

두 점을 지정하여 화살표를 그릴 수 있으며, 단방향 또는 양방향 화살표를 선택할 수 있습니다. React-Konva의 Arrow 컴포넌트를 사용하여 구현됩니다. 여러 도형을 선택한 후 Ctrl+G를 누르면 그룹으로 묶이고, 그룹 전체를 하나의 단위로 이동하거나 변형할 수 있습니다. Ctrl+Shift+G로 그룹을 해제할 수 있습니다.

### Undo/Redo

History Stack을 사용하여 실행 취소와 다시 실행 기능을 구현합니다. 도형이 추가, 수정, 삭제될 때마다 현재 상태의 스냅샷을 히스토리에 저장하고, Ctrl+Z로 이전 상태로 되돌릴 수 있습니다. 메모리 관리를 위해 최대 50개의 히스토리만 유지하고, Deep Copy를 통해 불변성을 보장합니다. Undo/Redo 시에도 Supabase Realtime을 통해 변경사항이 다른 사용자에게 전송됩니다.

### 저장 및 공유

작업한 내용은 Supabase Database에 자동으로 저장됩니다. 각 룸은 고유한 ID를 가지며, URL 파라미터로 roomId를 전달하여 다른 사용자를 초대할 수 있습니다. 읽기 전용 또는 편집 가능 권한을 설정할 수 있습니다. Stage의 toDataURL 메서드를 사용하여 현재 캔버스를 PNG 이미지로 내보낼 수 있으며, pixelRatio를 2로 설정하여 고해상도 이미지를 생성합니다.

### 오프라인 모드 및 재연결

네트워크 연결이 끊어져도 로컬에서 계속 작업할 수 있습니다. 오프라인 중 발생한 변경사항은 IndexedDB에 큐잉되고, 연결이 복구되면 자동으로 서버에 전송됩니다. Dexie.js 라이브러리를 사용하여 IndexedDB를 쉽게 다룰 수 있습니다. 재연결 시 오프라인 중 다른 사용자가 수정한 내용과 충돌이 발생하면, 사용자에게 모달을 표시하여 "내 것 유지" 또는 "상대방 것 수용" 중 하나를 선택하도록 합니다.

### 성능 최적화 - Viewport Culling

10,000개 이상의 도형이 있어도 60fps를 유지하기 위해 화면에 보이는 도형만 렌더링합니다. Viewport Bounds를 계산하여 현재 화면 영역을 파악하고, 각 도형의 위치가 이 영역 안에 있는지 확인합니다. useMemo를 사용하여 viewport나 shapes가 변경될 때만 필터링을 수행하고, 화면 밖의 도형은 렌더링하지 않습니다.

### 성능 최적화 - Layer 분리

React-Konva의 Layer를 여러 개로 분리하여 부분 렌더링을 구현합니다. background Layer에는 그리드를, shapes Layer에는 사용자가 그린 도형을, ui Layer에는 커서와 선택 박스를 배치합니다. 커서가 이동해도 background와 shapes Layer는 재렌더링되지 않아 성능이 크게 향상됩니다.

### 키보드 단축키

Ctrl+Z로 실행 취소, Ctrl+Shift+Z로 다시 실행, Delete로 선택 도형 삭제, Ctrl+A로 전체 선택, Ctrl+G로 그룹화, Arrow Keys로 선택 도형 이동 등의 키보드 단축키를 지원합니다. useEffect에서 keydown 이벤트를 리스닝하고, 텍스트 입력 중에는 단축키가 동작하지 않도록 처리합니다.

---

## 구현하면서 고민한점

(비워두기)

---

## 스프린트별 진행할 작업

### Sprint 1 - 캔버스 엔진 및 기본 도형 (1주)

무한 캔버스와 기본 도형 그리기 구현

**Frontend 작업**

- Vite + React + TypeScript 프로젝트 셋업
- React-Konva 설치 및 Stage, Layer 구조 구현
- Viewport 상태 관리 (x, y, zoom)
- Screen과 Canvas 좌표 변환 로직 구현
- 팬/줌 기능 (Space + Drag, Mouse Wheel)
- 사각형/원 그리기 도구 구현
- rough.js 통합하여 손그림 스타일 적용
- Zustand 스토어 설계 (도구 모드, 도형 배열, viewport)

**Backend 작업**

- Supabase 프로젝트 생성
- Database 스키마 설계 (rooms, shapes, users 테이블)
- Supabase Auth 설정

**산출물**

- 로컬에서 동작하는 화이트보드
- 사각형, 원 그리기 기능
- 팬/줌 기능

---

### Sprint 2 - 선택 및 변형 도구 (1주)

도형 선택, 크기 조절, 회전, 삭제 기능 구현

**Frontend 작업**

- 선택 도구 구현 (사각형 영역 드래그)
- Transformer 통합 (크기 조절, 회전 핸들)
- 키보드 단축키 (Delete, Ctrl+A, Ctrl+D)
- 도형 복제 기능
- Z-Index 관리 (Bring to Front, Send to Back)
- 정렬 도구 (Align Left/Center/Right, Top/Middle/Bottom)

**산출물**

- 도형 선택 및 변형 기능 완성
- 키보드 단축키 동작

---

### Sprint 3 - 실시간 협업 (Supabase Realtime) (1.5주)

Supabase Realtime을 활용한 실시간 동기화 구현

**Frontend 작업**

- Supabase Client 설정
- Realtime Channel 생성 및 구독
- Broadcast로 도형 CRUD 이벤트 전송/수신
  - shape-added 이벤트
  - shape-updated 이벤트
  - shape-deleted 이벤트
- Optimistic Update 패턴 구현
- Presence로 온라인 사용자 추적
- 커서 위치 실시간 공유 (Throttle 적용)
- 사용자별 고유 색상 할당

**Backend 작업**

- Supabase Realtime 설정 및 권한 구성
- Database에 도형 데이터 저장 및 로드

**산출물**

- 2명 이상 동시 접속 및 실시간 동기화
- 커서 공유 기능
- 온라인 사용자 목록 표시

---

### Sprint 4 - 고급 도구 및 최적화 (1.5주)

텍스트, 자유 곡선, 화살표 도구 및 성능 최적화 구현

**Frontend 작업**

- 텍스트 도구 (더블클릭으로 편집 모드, contentEditable 오버레이)
- 자유 곡선 + 필압 지원
  - Pointer Events API 통합
  - perfect-freehand 라이브러리 사용
  - Palm Rejection (펜만 감지)
- 화살표 도구 (단방향, 양방향)
- 그룹화 기능 (Ctrl+G, Ctrl+Shift+G)
- Viewport Culling 구현 (10,000개 도형에서 60fps)
- Layer 분리 (background, shapes, ui)
- Throttle/Debounce 적용

**산출물**

- 모든 도형 도구 완성
- 필압 지원
- 성능 최적화 완료

---

### Sprint 5 - Undo/Redo 및 오프라인 모드 (1주)

실행 취소, 저장, 오프라인 모드 구현

**Frontend 작업**

- History Stack 구현
- Undo/Redo 기능 (Ctrl+Z, Ctrl+Shift+Z)
- 네트워크 상태 감지 (isConnected)
- IndexedDB 로컬 큐잉 (Dexie.js)
- 재연결 시 오프라인 큐 동기화
- 충돌 해결 UX (모달로 선택 제공)
- PNG 내보내기 (Stage.toDataURL)
- 공유 링크 생성 (URL 파라미터로 roomId 전달)

**Backend 작업**

- 룸별 권한 관리 (읽기 전용, 편집 가능)

**산출물**

- Undo/Redo 기능
- 오프라인 모드 및 재연결
- PNG 내보내기
- 공유 링크
- 완성된 화이트보드 (Vercel 배포)

---

### Sprint 6 - 마무리 및 테스트 (선택사항, 1주)

튜토리얼, 테스트, 문서화

**Frontend 작업**

- 온보딩 튜토리얼 (첫 방문 시 도구 설명)
- 키보드 단축키 치트시트
- 반응형 디자인
- E2E 테스트 (Playwright)
- 단위 테스트 (Jest)

**산출물**

- 사용자 가이드
- 테스트 코드
- 배포 완료
