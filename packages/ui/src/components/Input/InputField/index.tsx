import { InputHTMLAttributes, forwardRef, useRef, useState, useId } from 'react';

import { useInputContext } from '../InputProvider';
import type { InputSize, InputStatus } from '../InputProvider';
import * as S from './InputField.styles';

export interface InputFieldProps
  extends Omit<InputHTMLAttributes<HTMLInputElement>, 'size'> {
  size?: InputSize;
  status?: InputStatus;
  startIcon?: React.ReactNode;
  endIcon?: React.ReactNode;
  endButton?: React.ReactNode;
}

const InputField = forwardRef<HTMLInputElement, InputFieldProps>(
  (
    {
      size: sizeProp,
      status: statusProp,
      disabled: disabledProp,
      readOnly: readOnlyProp,
      startIcon,
      endIcon,
      endButton,
      id: idProp,
      type,
      onChange,
      ...rest
    },
    ref,
  ) => {
    const context = useInputContext();
    const internalRef = useRef<HTMLInputElement>(null);
    const [selectedFileName, setSelectedFileName] = useState<string>('');
    const [isDragging, setIsDragging] = useState(false);
    const autoGeneratedId = useId();

    const inputSize = context?.size ?? sizeProp ?? 'medium';
    const status = statusProp ?? 'default';
    const disabled = disabledProp ?? false;
    const readOnly = readOnlyProp ?? false;
    // 우선순위: 명시적 id > 자동 생성 ID
    const inputId = idProp ?? autoGeneratedId;

    const isFileInput = type === 'file';

    // 파일명 업데이트 헬퍼 함수
    const updateFileName = (files: FileList | null) => {
      if (!files || files.length === 0) {
        setSelectedFileName('');
      } else if (files.length === 1) {
        setSelectedFileName(files[0].name);
      } else {
        setSelectedFileName(`${files.length}개의 파일 선택됨`);
      }
    };

    const handleWrapperClick = () => {
      const inputElement =
        ref && 'current' in ref ? ref.current : internalRef.current;

      if (isFileInput) {
        inputElement?.click();
      } else {
        inputElement?.focus();
      }
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      if (isFileInput) {
        updateFileName(e.target.files);
      }
      onChange?.(e);
    };

    const handleDragOver = (e: React.DragEvent) => {
      if (!isFileInput || disabled) return;
      e.preventDefault();
      setIsDragging(true);
    };

    const handleDragLeave = (e: React.DragEvent) => {
      if (!isFileInput || disabled) return;
      e.preventDefault();
      setIsDragging(false);
    };

    const handleDrop = (e: React.DragEvent) => {
      if (!isFileInput || disabled) return;
      e.preventDefault();
      setIsDragging(false);

      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        const inputElement =
          ref && 'current' in ref ? ref.current : internalRef.current;

        if (inputElement) {
          // DataTransfer 객체 생성 및 파일 추가
          try {
            const dataTransfer = new DataTransfer();
            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              if (file) {
                dataTransfer.items.add(file);
              }
            }
            inputElement.files = dataTransfer.files;
          } catch (error) {
            // DataTransfer를 지원하지 않는 브라우저의 경우 직접 할당
            inputElement.files = files;
          }

          // 파일명 업데이트
          updateFileName(inputElement.files);

          // onChange 이벤트 트리거
          const event = new Event('change', { bubbles: true });
          Object.defineProperty(event, 'target', {
            writable: false,
            value: inputElement,
          });
          onChange?.(event as unknown as React.ChangeEvent<HTMLInputElement>);
        }
      }
    };

    if (isFileInput) {
      return (
        <S.FileInputWrapper
          inputSize={inputSize}
          status={status}
          disabled={disabled}
          isDragging={isDragging}
          onClick={handleWrapperClick}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
        >
          <S.HiddenFileInput
            ref={ref ?? internalRef}
            id={inputId}
            type="file"
            disabled={disabled}
            aria-invalid={status === 'error'}
            onChange={handleFileChange}
            {...rest}
          />
          {startIcon && <S.IconSlot>{startIcon}</S.IconSlot>}
          <S.FileInputContent>
            <S.FileInputButton>파일 선택</S.FileInputButton>
            <S.FileInputText>
              {selectedFileName || '선택된 파일 없음'}
            </S.FileInputText>
          </S.FileInputContent>
        </S.FileInputWrapper>
      );
    }

    return (
      <S.Wrapper
        inputSize={inputSize}
        status={status}
        disabled={disabled}
        readOnly={readOnly}
        onClick={handleWrapperClick}
      >
        {startIcon && <S.IconSlot>{startIcon}</S.IconSlot>}
        <S.NativeInput
          ref={ref ?? internalRef}
          id={inputId}
          type={type}
          disabled={disabled}
          readOnly={readOnly}
          aria-invalid={status === 'error'}
          onChange={onChange}
          {...rest}
        />
        {endButton ? (
          <S.ButtonSlot>{endButton}</S.ButtonSlot>
        ) : endIcon ? (
          <S.IconSlot>{endIcon}</S.IconSlot>
        ) : null}
      </S.Wrapper>
    );
  },
);

InputField.displayName = 'InputField';

export default InputField;
